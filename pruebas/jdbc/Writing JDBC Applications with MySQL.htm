<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0042)http://www.kitebird.com/articles/jdbc.html -->
<HTML><HEAD><TITLE>Writing JDBC Applications with MySQL</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><!-- this file was generated by troffcvt and tc2html -->
<META content="MSHTML 6.00.2800.1106" name=GENERATOR></HEAD>
<BODY>
<H1>
<CENTER>Writing JDBC Applications with MySQL<BR></CENTER>
<CENTER></CENTER></H1>
<CENTER>
<P><I>Paul DuBois<BR><A 
href="mailto:paul@kitebird.com">paul@kitebird.com<BR></A></I></CENTER>
<CENTER>
<P>Document revision: 1.01<BR>Last update: 2003-01-24<BR></CENTER>
<H2>Table of Contents </H2><!-- INSERT TOC HERE --><!-- TOC BEGIN -->
<UL>
  <LI><A href="http://www.kitebird.com/articles/jdbc.html#TOC_1">Preliminary 
  Requirements</A> 
  <LI><A href="http://www.kitebird.com/articles/jdbc.html#TOC_2">Connecting to 
  the MySQL Server</A> 
  <LI><A href="http://www.kitebird.com/articles/jdbc.html#TOC_3">Issuing 
  Queries</A> 
  <UL>
    <LI><A href="http://www.kitebird.com/articles/jdbc.html#TOC_4">Issuing 
    Queries That Return No Result Set</A> 
    <LI><A href="http://www.kitebird.com/articles/jdbc.html#TOC_5">Issuing 
    Queries That Return a Result Set</A> 
    <UL>
      <LI><A href="http://www.kitebird.com/articles/jdbc.html#TOC_6">Using 
      Placeholders</A> </LI></UL>
    <LI><A href="http://www.kitebird.com/articles/jdbc.html#TOC_7">Error 
    Handling</A> </LI></UL>
  <LI><A href="http://www.kitebird.com/articles/jdbc.html#TOC_8">Resources</A> 
  <LI><A 
  href="http://www.kitebird.com/articles/jdbc.html#TOC_9">Acknowledgment</A> 
  </LI></UL><!-- TOC END --><BR>
<P>You can write MySQL applications in a variety of languages. The languages 
that most people use with MySQL are PHP and Perl, but a sometimes overlooked 
option is the MySQL Connector/J driver, which allows you to develop Java 
applications that interact with your MySQL server.<BR>
<P>MySQL Connector/J works within the framework of the Java JDBC interface, an 
API that allows Java programs to use database servers in a portable way. JDBC is 
based on an approach similar to that used in the design of Perl and Ruby DBI 
modules, Python's DB-API module, and PHP's PEAR::DB class. This approach uses a 
two-tier architecture:<BR>
<UL>
  <LI>The top level is visible to application programs and presents an abstract 
  interface for connecting to and using database engines. The application 
  interface does not depend on details specific to particular engines.<BR>
  <LI>The lower level consists of drivers for individual database engines. Each 
  driver handles the details necessary to map the abstract application interface 
  onto operations that a specific engine will understand.<BR></LI></UL>The JDBC 
interface allows developers to write applications that can be used with 
different databases with a minimum of porting effort. Once a driver for a given 
server engine is installed, JDBC applications can communicate with any server of 
that type. By using MySQL Connector/J, your Java programs can access MySQL 
databases.<BR>
<P><B>Note:</B> MySQL Connector/J is the successor to the MM.MySQL driver. If 
you have JDBC programs written for MM.MySQL, they should work with MySQL 
Connector/J as well, although you may want to update the driver class name used 
in your programs. Just replace instances of <TT>org.gjt.mm.mysql</TT> in your 
Java source files with <TT>com.mysql.jdbc</TT> and recompile.<BR><A name=TOC_1>
<H2>Preliminary Requirements </H2></A><BR>
<P>To use Java applications with MySQL, you may need to install some additional 
software:<BR>
<UL>
  <LI>If you want to compile and run Java programs, you'll need a Java compiler 
  (such as <I>javac</I> or <I>jikes</I>) and a runtime environment. If these are 
  not already installed on your system, you can get them by obtaining a Java 
  Software Development Kit (SDK) from <A 
  href="http://java.sun.com/"><I>java.sun.com</I></A>.<BR>
  <LI>If you want only to run precompiled applications, no compiler is 
  necessary, but you'll still need a Java Runtime Environment (JRE). This too 
  may be obtained from <A 
  href="http://java.sun.com/"><I>java.sun.com</I></A>.<BR></LI></UL>This article 
assumes that you'll write and compile your own programs, and thus that you have 
a Java SDK installed. Once you compile a Java program, however, you can deploy 
it to other machines, even ones that have only a runtime environment. This works 
even in heterogenous installations, because Java is platform-independent. 
Applications compiled on one platform can be expected to work on other 
platforms. For example, you can develop on a Linux box and deploy on 
Windows.<BR><A name=TOC_2>
<H2>Connecting to the MySQL Server </H2></A><BR>
<P>To connect to the MySQL server, register the JDBC driver you plan to use, 
then invoke its <TT>getConnection()</TT> method. The following short program, 
<I>Connect.java</I>, shows how to connect to and disconnect from a server 
running on the local host. It accesses a database named <TT>test</TT>, using a 
MySQL account with a user name and password of <TT>testuser</TT> and 
<TT>testpass</TT>:<BR><PRE>   import java.sql.*;

   public class Connect
   {
       public static void main (String[] args)
       {
           Connection conn = null;

           try
           {
               String userName = "testuser";
               String password = "testpass";
               String url = "jdbc:mysql://localhost/test";
               Class.forName ("com.mysql.jdbc.Driver").newInstance ();
               conn = DriverManager.getConnection (url, userName, password);
               System.out.println ("Database connection established");
           }
           catch (Exception e)
           {
               System.err.println ("Cannot connect to database server");
           }
           finally
           {
               if (conn != null)
               {
                   try
                   {
                       conn.close ();
                       System.out.println ("Database connection terminated");
                   }
                   catch (Exception e) { /* ignore close errors */ }
               }
           }
       }
   }
</PRE>Compile <I>Connect.java</I> to produce a class file <I>Connect.class</I> 
that contains executable Java code:<BR><PRE>   % <B>javac Connect.java</B>
</PRE>Then invoke the class file as follows and it should connect to and 
disconnect from your MySQL server:<BR><PRE>   % <B>java Connect</B>
   Database connection established
   Database connection terminated
</PRE>If you have trouble compiling <I>Connect.java</I>, double check that you 
have a Java Software Development Kit installed and make sure that the MySQL 
Connector/J driver is listed in your <TT>CLASSPATH</TT> environment 
variable.<BR>
<P>The arguments to <TT>getConnection()</TT> are the connection URL and the user 
name and password of a MySQL account. As illustrated by <I>Connect.java</I>, 
JDBC URLs for MySQL consist of <TT>jdbc:mysql://</TT> followed by the name of 
the MySQL server host and the database name. An alternate syntax for specifying 
the user and password is to add them as parameters to the end of the connection 
URL:<BR><PRE>   jdbc:mysql://localhost/test?user=testuser&amp;password=testpass
</PRE>When you specify a URL using this second format, <TT>getConnection()</TT> 
requires only one argument. For example, the code for connecting to the MySQL 
server in <I>Connect.java</I> could have been written like this:<BR><PRE>   String userName = "testuser";
   String password = "testpass";
   String url = "jdbc:mysql://localhost/test?user="
                   + userName
                   + "&amp;password="
                   + password;
   Class.forName ("com.mysql.jdbc.Driver").newInstance ();
   conn = DriverManager.getConnection (url);
</PRE><TT>getConnect()</TT> returns a <TT>Connection</TT> object that may be 
used to interact with MySQL by issuing queries and retrieving their results. 
(The next section describes how to do this.) When you're done with the 
connection, invoke its <TT>close()</TT> method to disconnect from the MySQL 
server.<BR>
<P>To increase the portability of your applications, you can store the 
connection parameters (host, database, user name, and password) in a Java 
properties file and read the properties at runtime. Then they need not be listed 
in the program itself. This allows you to change the server to which the program 
connects by editing the properties file, rather than by having to recompile the 
program.<BR><A name=TOC_3>
<H2>Issuing Queries </H2></A><BR>
<P>To process SQL statements in a JDBC-based application, create a 
<TT>Statement</TT> object from your <TT>Connection</TT> object. 
<TT>Statement</TT> objects support an <TT>executeUpdate()</TT> method for 
issuing queries that modify the database and return no result set, and an 
<TT>executeQuery()</TT> method for queries that do return a result set. The 
query-processing examples in this article use the following table, 
<TT>animal</TT>, which contains an integer <TT>id</TT> column and two string 
columns, <TT>name</TT> and <TT>category</TT>:<BR><PRE>   CREATE TABLE animal
   (
       id          INT UNSIGNED NOT NULL AUTO_INCREMENT,
       PRIMARY KEY (id),
       name        CHAR(40),
       category    CHAR(40)
   )
</PRE><TT>id</TT> is an <TT>AUTO_INCREMENT</TT> column, so MySQL automatically 
assigns successive values 1, 2, 3, ... as records are added to the table.<BR><A 
name=TOC_4>
<H3>Issuing Queries That Return No Result Set </H3></A><BR>
<P>The following example obtains a <TT>Statement</TT> object from the 
<TT>Connection</TT> object, then uses it to create and populate the 
<TT>animal</TT> table. <TT>DROP</TT> <TT>TABLE</TT>, <TT>CREATE</TT> 
<TT>TABLE</TT>, and <TT>INSERT</TT> all are statements that modify the database, 
so <TT>executeUpdate()</TT> is the appropriate method for issuing them:<BR><PRE>   Statement s = conn.createStatement ();
   int count;
   s.executeUpdate ("DROP TABLE IF EXISTS animal");
   s.executeUpdate (
               "CREATE TABLE animal ("
               + "id INT UNSIGNED NOT NULL AUTO_INCREMENT,"
               + "PRIMARY KEY (id),"
               + "name CHAR(40), category CHAR(40))");
   count = s.executeUpdate (
               "INSERT INTO animal (name, category)"
               + " VALUES"
               + "('snake', 'reptile'),"
               + "('frog', 'amphibian'),"
               + "('tuna', 'fish'),"
               + "('racoon', 'mammal')");
   s.close ();
   System.out.println (count + " rows were inserted");
</PRE>The <TT>executeUpdate()</TT> method returns the number of rows affected by 
a query. As shown above, the count is used to report how many rows the 
<TT>INSERT</TT> statement added to the <TT>animal</TT> table.<BR>
<P>A <TT>Statement</TT> object may be used to issue several queries. When you're 
done with it, invoke its <TT>close()</TT> method to dispose of the object and 
free any resources associated with it.<BR><A name=TOC_5>
<H3>Issuing Queries That Return a Result Set </H3></A><BR>
<P>For statements such as <TT>SELECT</TT> queries that retrieve information from 
the database, use <TT>executeQuery()</TT>. After calling this method, create a 
<TT>ResultSet</TT> object and use it to iterate through the rows returned by 
your query. The following example shows one way to retrieve the contents of the 
<TT>animal</TT> table:<BR><PRE>   Statement s = conn.createStatement ();
   s.executeQuery ("SELECT id, name, category FROM animal");
   ResultSet rs = s.getResultSet ();
   int count = 0;
   while (rs.next ())
   {
       int idVal = rs.getInt ("id");
       String nameVal = rs.getString ("name");
       String catVal = rs.getString ("category");
       System.out.println (
               "id = " + idVal
               + ", name = " + nameVal
               + ", category = " + catVal);
       ++count;
   }
   rs.close ();
   s.close ();
   System.out.println (count + " rows were retrieved");
</PRE><TT>executeQuery()</TT> does not return a row count, so if you want to 
know how many rows a result set contains, you should count them yourself as you 
fetch them.<BR>
<P>To obtain the column values from each row, invoke 
<TT>get</TT><TT><I>XXX</I></TT><TT>()</TT> methods that match the column data 
types. The <TT>getInt()</TT> and <TT>getString()</TT> methods used in the 
preceding example return integer and string values. As the example shows, these 
methods may be called using the name of a result set column. You can also fetch 
values by position. For the result set retrieved by the <TT>SELECT</TT> query in 
the example, <TT>id</TT>, <TT>name</TT>, and <TT>category</TT> are at column 
positions 1, 2 and 3 and thus could have been obtained like this:<BR><PRE>   int idVal = rs.getInt (1);
   String nameVal = rs.getString (2);
   String catVal = rs.getString (3);
</PRE><TT>ResultSet</TT> objects, like <TT>Statement</TT> objects, should be 
closed when you're done with them.<BR>
<P>To check whether or not a column value is <TT>NULL</TT>, invoke the result 
set object's <TT>wasNull()</TT> method after fetching the value. For example, 
you could check for a <TT>NULL</TT> value in the <TT>name</TT> column like 
this:<BR><PRE>   String nameVal = rs.getString ("name");
   if (rs.wasNull ())
       nameVal = "(no name available)";
</PRE><A name=TOC_6><B>Using Placeholders</B></A><BR>
<P>Sometimes it's necessary to construct queries from values containing 
characters that require special treatment. For example, in queries, string 
values are written enclosed within quotes, but any quote characters in the 
string itself should be doubled or escaped with a backslash to avoid creating 
malformed SQL. In this case, it's much easier to let JDBC handle the escaping 
for you, rather than fooling around trying to do so yourself. To use this 
approach, create a different kind of statement (a <TT>PreparedStatement</TT>), 
and refer to the data values in the query string by means of placeholder 
characters. Then tell JDBC to bind the data values to the placeholders and it 
will handle any special characters automatically.<BR>
<P>Suppose you have two variables <TT>nameVal</TT> and <TT>catVal</TT> from 
which you want to create a new record in the <TT>animal</TT> table. To do so 
without regard to whether or not the values contain special characters, issue 
the query like this:<BR><PRE>   PreparedStatement s;
   s = conn.prepareStatement (
               "INSERT INTO animal (name, category) VALUES(?,?)");
   s.setString (1, nameVal);
   s.setString (2, catVal);
   int count = s.executeUpdate ();
   s.close ();
   System.out.println (count + " rows were inserted");
</PRE>The '<TT>?</TT>' characters in the query string act as 
placeholders--special markers indicating where data values should be placed. The 
<TT>setString()</TT> method takes a placeholder position and a string value and 
binds the value to the appropriate placeholder, performing any special-character 
escaping that may be necessary. The method you use to bind a value depends on 
the data type. For example, <TT>setString()</TT> binds string values and 
<TT>setInt()</TT> binds integer values.<BR><A name=TOC_7>
<H3>Error Handling </H3></A><BR>
<P>If you want to trap errors, execute your JDBC operations within a 
<TT>try</TT> block and use an exception handler to display information about the 
cause of any problems that occur. JDBC provides <TT>getMessage()</TT> and 
<TT>getErrorCode()</TT> methods that may be invoked when an exception occurs to 
obtain the error message and the numeric error code. The following example 
deliberately issues a malformed query. When it runs, the <TT>executeQuery()</TT> 
method fails and raises an exception that is handled in the <TT>catch</TT> 
block:<BR><PRE>   try
   {
       Statement s = conn.createStatement ();
       s.executeQuery ("XYZ"); // issue invalid query
       s.close ();
   }
   catch (SQLException e)
   {
       System.err.println ("Error message: " + e.getMessage ());
       System.err.println ("Error number: " + e.getErrorCode ());
   }
</PRE><A name=TOC_8>
<H2>Resources </H2></A><BR>
<P>The following sites provide information about the tools discussed in this 
article:<BR>
<UL>
  <LI>Sun's Java site is a clearinghouse for all kinds of Java-related 
  information:<BR><PRE>   <A href="http://java.sun.com/">http://java.sun.com/
</A>
</PRE>You can obtain the Java Software Development Kit or Java Runtime 
  Environment here. The specification for the JDBC API is also available on this 
  site, should you wish to read more about it.<BR>
  <LI>The MySQL Connector/J driver is supported by MySQL AB. Connector/J author 
  Mark Matthews maintains the driver, which is available at:<BR><PRE>   <A href="http://www.mysql.com/">http://www.mysql.com/
</A>
</PRE>
  <LI>Introductory articles describing other MySQL APIs based on an architecture 
  similar to that used for JDBC may be found at:<BR><PRE>   <A href="http://www.kitebird.com/articles/">http://www.kitebird.com/articles/
</A>
</PRE>APIs discussed in the articles include Perl DBI, PHP PEAR::DB, Python 
  DB-API, and Ruby DBI.<BR></LI></UL><A name=TOC_9>
<H2>Acknowledgment </H2></A><BR>
<P>The original version of this article was written for NuSphere Corporation. 
The current version is an updated revision of the 
original.<BR></P></BODY></HTML>
